#### ros第三章
# ROS通信机制进阶
## 3.1 常用api
### 3.1.1 初始化
#### ROS初始化函数。
 * 该函数可以解析并使用节点启动时传入的参数(通过参数设置节点名称、命名空间...)   
 
 * 该函数有多个重载版本，如果使用NodeHandle建议调用该版本。 
 
 * \param argc 参数个数
 * \param argv 参数列表
 * \param name 节点名称，需要保证其唯一性，不允许包含命名空间
 * \param options 节点启动选项，被封装进了ros::init_options

示例：  
void init(int &argc, char **argv, const std::string& name, uint32_t options = 0);
### 3.1.2 话题与服务相关对象
在 roscpp 中，话题和服务的相关对象一般由 NodeHandle 创建。 
#### 发布对象
在 ROS master 注册并返回一个发布者对象，该对象可以发布消息
* 使用示例如下:  
*   ros::Publisher pub = handle.advertise<std_msgs::Empty>("my_topic", 1);  
* \param topic 发布消息使用的话题  
* \param queue_size 等待发送给订阅者的最大消息数量  
* \param latch (optional) 如果为 true,该话题发布的最后一条消息将被保存，并且后期当有订阅者连接时会将该消息发送给订阅者  
* \return 调用成功时，会返回一个发布对象  
示例：  

template <class M>
Publisher advertise(const std::string& topic, uint32_t queue_size, bool latch = false)  
#### 订阅对象
该函数将根据给定的话题在ROS master 注册，并自动连接相同主题的发布方，每接收到一条消息，都会调用回调
   * 函数，并且传入该消息的共享指针，该消息不能被修改，因为可能其他订阅对象也会使用该消息。
   * 
   * 使用示例如下:

void callback(const std_msgs::Empty::ConstPtr& message)
{
}

ros::Subscriber sub = handle.subscribe("my_topic", 1, callback);

   *
* \param M [template] M 是指消息类型
* \param topic 订阅的话题
* \param queue_size 消息队列长度，超出长度时，头部的消息将被弃用
* \param fp 当订阅到一条消息时，需要执行的回调函数
* \return 调用成功时，返回一个订阅者对象，失败时，返回空对象
详见讲义。
#### 服务对象
 生成服务端对象
* 该函数可以连接到 ROS master，并提供一个具有给定名称的服务对象。
* 使用示例如下:
\verbatim
bool callback(std_srvs::Empty& request, std_srvs::Empty& response)
{
return true;
}

ros::ServiceServer service = handle.advertiseService("my_service", callback);
\endverbatim
* \param service 服务的主题名称
* \param srv_func 接收到请求时，需要处理请求的回调函数
* \return 请求成功时返回服务对象，否则返回空对象:
#### 客户端对象
  * 创建一个服务客户端对象
  * 当清除最后一个连接的引用句柄时，连接将被关闭。
  * @param service_name 服务主题名称
 template<class Service>
 ServiceClient serviceClient(const std::string& service_name, bool persistent = false, const M_string& header_values = M_string())
### 3.1.3 回旋函数
1 spin();  
2 spinOnce();  
相同点:二者都用于处理回调函数；

不同点:ros::spin() 是进入了循环执行回调函数，而 ros::spinOnce() 只会执行一次回调函数(没有循环)，在 ros::spin() 后的语句不会执行到，而 ros::spinOnce() 后的语句可以执行。
### 时间函数
    #include"ros/ros.h"
    // using namespace ros;
    void cb(const ros::TimerEvent& event){
        ROS_INFO("------");
        ROS_INFO("The moment the function is called:%.2f",event.current_real.toSec());
    }
    int main(int argc,char *argv[]){
        ros::init(argc,argv,"hello_time");
        ros::NodeHandle nh;
        ros::Time right_now=ros::Time::now();
        ROS_INFO("time right now:%.2f",right_now.toSec());
        ROS_INFO("time right now:%d",right_now.sec);
        ros::Time t1(20,313245533);
        ros::Time t2(100.35);
        ROS_INFO("t1=%.2f",t1.toSec());
        ROS_INFO("t2=%.2f",t2.toSec());
        // -----------------------------------------------------
        ROS_INFO("----------DURATION----------------");
        ros::Time start=ros::Time::now();
        ROS_INFO("start hibernation:%.2f",start.toSec());
        ros::Duration du(4.5);
        du.sleep();
        ros::Time end=ros::Time::now();
        ROS_INFO("hibernation end:%.2f",end.toSec());
        // ------------------------------------------------------
        ROS_INFO("---------------CACULATE TIME-----------");
        ros::Time begin=ros::Time::now();
        ros::Duration du1(5);
        ros::Time stop=begin+du1;
        ROS_INFO("strat hibernation:%.2f",begin.toSec());
        ROS_INFO("ending hibernation:%.2f",stop.toSec());

        //----------------------------------------
        ros::Duration du2=begin-stop;
        ROS_INFO("subtract moment:%.2f",du2.toSec());
        ros::Duration du3=du2+du1;
        ros::Duration du4=du1-du2;
        ROS_INFO("du1+du2=%.2f",du3.toSec());
        ROS_INFO("du1-du2=%.2f",du4.toSec());   

        // -------------------------------------------------
        ROS_INFO("-------------------TIMER------------");
        ros::Timer timer=nh.createTimer(ros::Duration(1),cb,false,false);
        timer.start();
        ros::spin();



        return 0;
    }
### 3.1.5 其他函数  
在发布实现时，一般会循环发布消息，循环的判断条件一般由节点状态来控制，C++中可以通过 ros::ok() 来判断节点状态是否正常，而 python 中则通过 rospy.is_shutdown() 来实现判断，导致节点退出的原因主要有如下几种:

    节点接收到了关闭信息，比如常用的 ctrl + c 快捷键就是关闭节点的信号；
    同名节点启动，导致现有节点退出；
    程序中的其他部分调用了节点关闭相关的API(C++中是ros::shutdown()，python中是rospy.signal_shutdown())

另外，日志相关的函数也是极其常用的，在ROS中日志被划分成如下级别:

    DEBUG(调试):只在调试时使用，此类消息不会输出到控制台；
    INFO(信息):标准消息，一般用于说明系统内正在执行的操作；
    WARN(警告):提醒一些异常情况，但程序仍然可以执行；
    ERROR(错误):提示错误信息，此类错误会影响程序运行；
    FATAL(严重错误):此类错误将阻止节点继续运行。   

    #include"ros/ros.h"
    int main(int argc,char *argv[]){
        ros::init(argc,argv,"hello_log");
        ros::NodeHandle nh;
        ROS_DEBUG("debug messages");
        ROS_INFO("normal messages");
        ROS_WARN("warning messages");
        ROS_ERROR("error messages");
        ROS_FATAL("critical error");
        return 0;
    }
### 3.2.1 自定义头文件
1 写头文件  
2 写可执行文件   
3 配置
### 3.2.2 自定义源文件
详见讲义




