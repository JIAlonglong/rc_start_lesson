##### ROS第五章
# tf静态坐标变换
## 发布方实现
新建的功能包需要包含以下依赖

tf2、tf2_ros、tf2_geometry_msgs、roscpp rospy std_msgs geometry_msgs

    #include"ros/ros.h"
    #include"tf2_ros/static_transform_broadcaster.h"
    #include"geometry_msgs/TransformStamped.h"
    #include"tf2/LinearMath/Quaternion.h"
    // 需求:发布两个坐标系的相对关系
    // 流程:1包含头文件
    // 2设置编码 节点初始化 
    // 3创建发布者对象
    // 4组织被发布的消息
    // 5发布数据
    // 6spin()
    int main(int argc,char* argv[]){
    // 2设置编码 节点初始化 
        setlocale(LC_ALL,"");
        ros::init(argc,argv,"static_pub");
        ros::NodeHandle nh;//非必须
        //3创建发布者对象
        tf2_ros::StaticTransformBroadcaster pub;
        // 4组织被发布的消息
        geometry_msgs::TransformStamped tfs;
        tfs.header.stamp=ros::Time::now();
        tfs.header.frame_id="base_link";
        tfs.child_frame_id="laser";
        tfs.transform.translation.x=0.2;
        tfs.transform.translation.y=0.0;
        tfs.transform.translation.z=0.5;
        //需要根据欧拉角转换
        tf2::Quaternion qtn;//创建四元数对象
        //向该对象设置欧拉角,这个对象可以将欧拉角转换成四元数
        qtn.setRPY(0,0,0);//欧拉角的单位是弧度
        tfs.transform.rotation.x=qtn.getX();
        tfs.transform.rotation.y=qtn.getY();
        tfs.transform.rotation.z=qtn.getZ();
        tfs.transform.rotation.w=qtn.getW();
        //5发布数据
        pub.sendTransform(tfs);
        //6spin();
        ros::spin();
        return 0;
    }
ps：

1、在编写完发布方实现后可以打开终端（以图形化的方式）输入rviz查看

2、打开终端-输入rostopic list-再输入rostopic echo /tf_static (你想监控的话题名称)

### 订阅方实现
    #include"ros/ros.h"
    #include"tf2_ros/transform_listener.h"
    #include"tf2_ros/buffer.h"
    #include "geometry_msgs/PointStamped.h"
    #include "tf2_geometry_msgs/tf2_geometry_msgs.h"

    // 订阅方:订阅发布的坐标相对关系,传入一个坐标点,调用tf实现变换
    // 流程:1包含头文件
    // 2编码.初始化.NodeHandle(必须)
    // 3创建订阅对象;-->订阅坐标系相对关系
    // 4组织一个坐标点数据
    // 5转换算法,需调用TF内置实现
    // 6最后输出
    int main(int argc,char *argv[]){
        //2编码 初始化 
        setlocale(LC_ALL,"");
        ros::init(argc,argv,"static_sub");
        ros::NodeHandle nh;
        //3创建订阅对象;-->订阅坐标系相对位置关系
        //3-1创建一个buffer缓存
        tf2_ros::Buffer buffer;
        //3-2再创建监听对象(监听对象可以将订阅到的数据存入buffer)
        tf2_ros::TransformListener listener(buffer);
        //组织一个坐标点数据
        geometry_msgs::PointStamped ps;
        ps.header.frame_id="laser";
        ps.header.stamp=ros::Time::now();
        ps.point.x=2.0;
        ps.point.y=3.0;
        ps.point.z=5.0;
        //添加休眠
        // ros::Duration(2).sleep();
        //5转换算法，需要调用tf内置实现
        ros::Rate rate(10);
        while(ros::ok){
            //核心代码 将ps转换成相对于base-link的坐标
            geometry_msgs::PointStamped ps_out;
            // 调用了buffer的转换函数transform
            // 参数1：被转换的坐标点
            // 参数2：目标坐标系
            // 返回值：输出的坐标点
            // ps1 调用时必须包含头文件 tf2_geometry_msgs/tf2_geometry_msgs.h
            // ps2 运行时存在的问题：抛出一个异常base_link不存在
            //     原因：订阅数据是一个耗时操作，可能调用transform转换函数时，坐标系的
            //     相对关系还没有订阅到，因此出现异常
            //     解决：方案1：在调用转换函数前，执行休眠
            //     方案2：进行异常处理（建议
            
            try
            {
                ps_out=buffer.transform(ps,"base_link");
            //6最后输出
            
            ROS_INFO("转换后的坐标：（%.2f,%.2f,%.2f),参考的坐标系：%s",
                        ps_out.point.x,
                        ps_out.point.y,
                        ps_out.point.z,
                        ps_out.header.frame_id.c_str()
                        );
            }
            catch(const std::exception& e)
            {
                // std::cerr << e.what() << '\n';
                ROS_INFO("异常消息：%s",e.what());
            }
            
            
            rate.sleep();
            ros::spinOnce();
        }

        return 0;
    }

# vscode快捷键
## Vscode缩进快捷键：
所谓批量缩进就是选中一段文本代码后，批量让其向左移动或者向右移动。

首先选中文本，后按住以下组合键

向左缩进：Ctrl + [ 或者 Shift+Tab

向右缩进：Ctrl + ] 或者 Tab实现文本的向左移动或者向右移动

与格式化不同，格式化同样可以批量处理缩进

批量缩进并不会对选中的代码进行格式化，只是会实现选中块代码左移或者右移，各有使用场景。

Visual Studio Code格式化代码

作用：主要是整理原代码的缩进，以及运算符的间隔等。

目的：使代码缩进清晰，更容易阅读。

快捷键如下：

On Windows 　　Shift + Alt + F

On Mac 　　Shift + Option + F

On Ubuntu　　 Ctrl + Shift + I




# TF 动态坐标变换
动态发布坐标关系

1新建功能包，添加依赖

2创建坐标相对关系发布方(同时需要订阅乌龟位姿信息，在这之后就可以通过rviz实现查看了

3创建坐标相对关系订阅方（非必须）

4执行

准备操作：启动roscore 

rosrun turtlesim turtlesim_node

rostopic list(查看话题类型)

rostopic info /turtle1/pose (查看消息格式)

rosmsg info turtlesim/Pose (查看消息的具体格式)

ps：消息是大写的，话题是小写的

查看程序运行结果可以 

1rostopic echo

2rviz

## 发布方

    #include"ros/ros.h"
    #include"turtlesim/Pose.h"
    #include"tf2_ros/transform_broadcaster.h"
    #include"geometry_msgs/TransformStamped.h"
    #include"tf2/LinearMath/Quaternion.h"

    // 发布方：需要订阅乌龟的位姿信息
    // 准备：
    //     话题：/turtle1/pose
    //     消息：/turtlesim/pose
    // 流程：
    //     1包含头文件
    //     2设置编码 初始化 NodeHandle
    //     3创建订阅对象，订阅/turtle1/pose
    //     4回调函数处理订阅的消息：将位姿信息转换成坐标相对关系并发布（关注）
    //     5spin（）

    void doPose(const turtlesim::Pose::ConstPtr& pose){
        //获取位姿信息，转换成坐标系相对关系（核心）并发布
        //a创建发布对象
        static tf2_ros::TransformBroadcaster pub;
        //b组织被发布的数据
        geometry_msgs::TransformStamped ts;
        ts.header.frame_id="world";
        ts.header.stamp=ros::Time::now();
        ts.child_frame_id="turtle1";
        //坐标偏移量设置
        ts.transform.translation.x=pose->x;
        ts.transform.translation.y=pose->y;    
        ts.transform.translation.z=0;
        //坐标系四元数
        // 位姿信息中没有四元数，但是有个偏航角度，又已知乌龟是2D，没有翻滚和俯仰角度，所以可以得出乌龟的欧拉角
        // 0 0 theta    
        tf2::Quaternion qtn;
        qtn.setRPY(0,0,pose->theta);

        ts.transform.rotation.x=qtn.getX();
        ts.transform.rotation.y=qtn.getY();
        ts.transform.rotation.z=qtn.getZ();
        ts.transform.rotation.w=qtn.getW();

        //c发布
        pub.sendTransform(ts);
    }
    int main(int argc,char *argv[]){
        // 2设置编码 初始化 NodeHandle
        setlocale(LC_ALL,"");
        ros::init(argc,argv,"dynamic_pub");
        ros::NodeHandle nh;
        // 3创建订阅对象，订阅/turtle1/pose
        ros::Subscriber sub=nh.subscribe("/turtle1/pose",100,doPose);
        // 4回调函数处理订阅的消息：将位姿信息转换成坐标相对关系并发布（关注）

        // 5spin（）
        ros::spin();
        return 0;
    }
## 订阅方
    #include"ros/ros.h"
    #include"tf2_ros/transform_listener.h"
    #include"tf2_ros/buffer.h"
    #include "geometry_msgs/PointStamped.h"
    #include "tf2_geometry_msgs/tf2_geometry_msgs.h"

    // 订阅方:订阅发布的坐标相对关系,传入一个坐标点,调用tf实现变换
    // 流程:1包含头文件
    // 2编码.初始化.NodeHandle(必须)
    // 3创建订阅对象;-->订阅坐标系相对关系
    // 4组织一个坐标点数据
    // 5转换算法,需调用TF内置实现
    // 6最后输出
    int main(int argc,char *argv[]){
        //2编码 初始化 
        setlocale(LC_ALL,"");
        ros::init(argc,argv,"static_sub");
        ros::NodeHandle nh;
        //3创建订阅对象;-->订阅坐标系相对位置关系
        //3-1创建一个buffer缓存
        tf2_ros::Buffer buffer;
        //3-2再创建监听对象(监听对象可以将订阅到的数据存入buffer)
        tf2_ros::TransformListener listener(buffer);
        //4组织一个坐标点数据
        geometry_msgs::PointStamped ps;
        ps.header.frame_id="turtle1";
        ps.header.stamp=ros::Time(0,0);
        ps.point.x=2.0;
        ps.point.y=3.0;
        ps.point.z=5.0;
        //添加休眠
        // ros::Duration(2).sleep();
        //5转换算法，需要调用tf内置实现
        ros::Rate rate(10);
        while(ros::ok){
            //核心代码 将ps转换成相对于base-link的坐标
            geometry_msgs::PointStamped ps_out;
            // 调用了buffer的转换函数transform
            // 参数1：被转换的坐标点
            // 参数2：目标坐标系
            // 返回值：输出的坐标点
            // ps1 调用时必须包含头文件 tf2_geometry_msgs/tf2_geometry_msgs.h
            // ps2 运行时存在的问题：抛出一个异常base_link不存在
            //     原因：订阅数据是一个耗时操作，可能调用transform转换函数时，坐标系的
            //     相对关系还没有订阅到，因此出现异常
            //     解决：方案1：在调用转换函数前，执行休眠
            //     方案2：进行异常处理（建议
            
            try
            {
                ps_out=buffer.transform(ps,"world");
            //6最后输出
            
            ROS_INFO("转换后的坐标：（%.2f,%.2f,%.2f),参考的坐标系：%s",
                        ps_out.point.x,
                        ps_out.point.y,
                        ps_out.point.z,
                        ps_out.header.frame_id.c_str()
                        );
            }
            catch(const std::exception& e)
            {
                // std::cerr << e.what() << '\n';
                ROS_INFO("异常消息：%s",e.what());
            }
            
            
            rate.sleep();
            ros::spinOnce();
        }

        return 0;
    }

ps：ctrl+shift+b编译不报错之后

打开终端 先启动turtlesim_node 

# 多坐标变换

## 发布方
    #include"ros/ros.h"
    #include"tf2_ros/transform_listener.h"
    #include"tf2_ros/buffer.h"
    #include"geometry_msgs/PointStamped.h"
    #include"tf2_geometry_msgs/tf2_geometry_msgs.h"
    #include"geometry_msgs/TransformStamped.h"
    // 订阅方实现：1计算son1与son2的相对关系 2计算son1中的某个坐标点在son2中的坐标值
    // 流程：1包含头文件
    // 2编码 初始化 nodehandle
    // 3创建订阅对象
    // 4编写解析逻辑
    // 5spinOnce（）
    int main(int argc,char *argv[]){
        // 2编码 初始化 nodehandle
        setlocale(LC_ALL,"");
        ros::init(argc,argv,"tfs_sub");
        ros::NodeHandle nh;
        // 3创建订阅对象
        tf2_ros::Buffer buffer;
        tf2_ros::TransformListener sub(buffer);
        // 4编写解析逻辑

        //创建坐标点
        geometry_msgs::PointStamped psAtSon1;
        psAtSon1.header.stamp=ros::Time::now();
        psAtSon1.header.frame_id="son1";
        psAtSon1.point.x=1.0;
        psAtSon1.point.y=2.0;
        psAtSon1.point.z=3.0;

        ros::Rate rate(10);
        while(ros::ok()){
            //核心
            try
            {
                // 1计算son1与son2的相对关系
                // A相对于B的坐标系关系
                // 参数1 目标坐标系 B
                // 参数2 源坐标系 A
                // 参数3 ros：：Time（0）取时间间隔最短的两个坐标关系帧计算相对关系
                // 返回值 geometry_msgs::TransformStamped 源相对于目标坐标系的相对关系
                geometry_msgs::TransformStamped Son1ToSon2=buffer.lookupTransform("son2","son1",ros::Time(0));
                ROS_INFO("son1相对于son2的信息:父极:%s,子级：%s 偏移量：（%.2f,%.2f,%.2f)",
                        Son1ToSon2.header.frame_id.c_str(),
                        Son1ToSon2.header.frame_id.c_str(),
                        Son1ToSon2.transform.translation.x,
                        Son1ToSon2.transform.translation.y,
                        Son1ToSon2.transform.translation.z 
                        
                        );
                // 2计算son1中的某个坐标点在son2中的坐标值
                geometry_msgs::PointStamped psAtSon2=buffer.transform(psAtSon1,"son2");
                ROS_INFO("坐标点在Son2中的值(%.2f,%.2f,%.2f)",
                        psAtSon2.point.x,
                        psAtSon2.point.y,
                        psAtSon2.point.z
                        );
            }
            catch(const std::exception& e)
            {
                ROS_INFO("错误提示：%s",e.what());
            }
            
        }
        // 5spinOnce（）
        return 0;
    }

转换之后的结果是（3，2，3）

# 坐标关系查看
## 步骤
1查看自己的tf2_tools有没有安装

    rospack find tf2_tools

2若没有安装 则使用

    sudo apt install ros-noetic-tf2-tools

进行安装

3打开节点（这里直接打开上一节的launch文件

    roslaunch tf03_tfs tfs_c.launch

4使用tf2_tools

    rosrun tf2_tools view_frames.py

5调用查看命令打开文件或者进入文件所在目录打开pdf文件

    evince frames.pdf

！[frames.py](/home/cvmf8sm/demo04_ws/frames.pdf)

# TF坐标变换实操

### 大白话：
让两只乌龟都发布相对于world窗体的坐标

然后计算两坐标之间的位置关系 就可以实现让其中一个乌龟1追踪乌龟2了

## 实现分析:

乌龟跟随实现的核心，是乌龟A和B都要发布相对世界坐标系的坐标信息，然后，订阅到该信息需要转换获取A相对于B坐标系的信息，最后，再生成速度信息，并控制B运动。

    启动乌龟显示节点
    在乌龟显示窗体中生成一只新的乌龟(需要使用服务)
    编写两只乌龟发布坐标信息的节点
    编写订阅节点订阅坐标信息并生成新的相对关系生成速度信息

## 实现流程:

    新建功能包，添加依赖

    编写服务客户端，用于生成一只新的乌龟

    编写发布方，发布两只乌龟的坐标信息

    编写订阅方，订阅两只乌龟信息，生成速度信息并发布

    运行

## note：
生成另外一只新的乌龟以及订阅乌龟坐标信息在第二章ROS实操的23小节有提到

teleop 订阅的话题是turtle1/cmd_vel

所以键盘控制只能控制turtle1

## 准备：
###  1编写launch文件

因为本案例涉及到多个节点，所以首先编写一个launch文件，使启动方便
这个launch文件需要做到：

1启动turtle1显示节点及键盘控制节点

2启动turtle2生成节点

3启动两乌龟发布相对于世界坐标系的坐标节点

### 2编写turtle2生成节点
### 3编写两乌龟发布坐标节点（相对于世界坐标系）
### 4编写组织速度消息节点

## 生成turtle2节点
    #include"ros/ros.h"
    #include"turtlesim/Spawn.h"
    int main(int argc,char *argv[]){
        ros::init(argc,argv,"service_call");
        ros::NodeHandle nh;
        ros::ServiceClient client=nh.serviceClient<turtlesim::Spawn>("/spawn");
        turtlesim::Spawn spawn;
        spawn.request.x=1.0;
        spawn.request.y=4.0;
        spawn.request.theta=1.57;
        spawn.request.name="turtle2";
        client.waitForExistence();
        bool flag=client.call(spawn);
        if (flag){
            ROS_INFO("Successful!the name of new turtle is:%s",spawn.response.name.c_str());
        }else{
            ROS_INFO("Fail...");
        }
        return 0;

    }

## 两乌龟发布坐标节点
    #include"ros/ros.h"
    #include"turtlesim/Pose.h"
    #include"tf2_ros/transform_broadcaster.h"
    #include"geometry_msgs/TransformStamped.h"
    #include"tf2/LinearMath/Quaternion.h"

    // 发布方：需要订阅乌龟的位姿信息
    // 准备：
    //     话题：/turtle1/pose
    //     消息：/turtlesim/pose
    // 流程：
    //     1包含头文件
    //     2设置编码 初始化 NodeHandle
    //     3创建订阅对象，订阅/turtle1/pose
    //     4回调函数处理订阅的消息：将位姿信息转换成坐标相对关系并发布（关注）
    //     5spin（）

    //声明变量接受传递的参数
    std::string turtle_name;

    void doPose(const turtlesim::Pose::ConstPtr& pose){
        
        //获取位姿信息，转换成坐标系相对关系（核心）并发布
        //a创建发布对象
        static tf2_ros::TransformBroadcaster pub;
        //b组织被发布的数据
        geometry_msgs::TransformStamped ts;
        ts.header.frame_id="world";
        ts.header.stamp=ros::Time::now();
        ////关键点2：动态传入
        // ts.child_frame_id="turtle1";
        ts.child_frame_id=turtle_name;
        //坐标偏移量设置
        ts.transform.translation.x=pose->x;
        ts.transform.translation.y=pose->y;    
        ts.transform.translation.z=0;
        //坐标系四元数
        // 位姿信息中没有四元数，但是有个偏航角度，又已知乌龟是2D，没有翻滚和俯仰角度，所以可以得出乌龟的欧拉角
        // 0 0 theta    
        tf2::Quaternion qtn;
        qtn.setRPY(0,0,pose->theta);

        ts.transform.rotation.x=qtn.getX();
        ts.transform.rotation.y=qtn.getY();
        ts.transform.rotation.z=qtn.getZ();
        ts.transform.rotation.w=qtn.getW();

        //c发布
        pub.sendTransform(ts);
    }
    int main(int argc,char *argv[]){
        setlocale(LC_ALL,"");
        ros::init(argc,argv,"dynamic_pub");
        ros::NodeHandle nh;
        ////解析launch文件通过args传入的参数
        if(argc!=2){
            ROS_ERROR("请传入一个参数");
            return 1;
        }else{
            turtle_name=argv[1];


        }
        // 2设置编码 初始化 NodeHandle
        
        // 3创建订阅对象，订阅/turtle1/pose
        ////关键点1：订阅的话题名称 turtle1或turtle2得是动态传入的
        // ros::Subscriber sub=nh.subscribe("/turtle1/pose",100,doPose);
        ros::Subscriber sub=nh.subscribe(turtle_name+"/pose",100,doPose);
        // 4回调函数处理订阅的消息：将位姿信息转换成坐标相对关系并发布（关注）

        // 5spin（）
        ros::spin();
        return 0;
    }
## 计算（组织速度消息节点）

    #include"ros/ros.h"
    #include"tf2_ros/transform_listener.h"
    #include"tf2_ros/buffer.h"
    #include"geometry_msgs/PointStamped.h"
    #include"tf2_geometry_msgs/tf2_geometry_msgs.h"
    #include"geometry_msgs/TransformStamped.h"
    #include"geometry_msgs/Twist.h"
    // 订阅方实现：1计算son1与son2的相对关系 2计算son1中的某个坐标点在son2中的坐标值
    // 流程：1包含头文件
    // 2编码 初始化 nodehandle
    // 3创建订阅对象
    // 4编写解析逻辑
    // 5spinOnce（）
    int main(int argc,char *argv[]){
        // 2编码 初始化 nodehandle
        setlocale(LC_ALL,"");
        ros::init(argc,argv,"tfs_sub");
        ros::NodeHandle nh;
        // 3创建订阅对象
        tf2_ros::Buffer buffer;
        tf2_ros::TransformListener sub(buffer);
        //A创建发布对象
        ros::Publisher pub=nh.advertise<geometry_msgs::Twist>("/turtle2/cmd_vel",100);
        // 4编写解析逻辑

        ros::Rate rate(10);
        while(ros::ok()){
            //核心
            try
            {
                // 1计算son1与son2的相对关系
                // A相对于B的坐标系关系
                // 参数1 目标坐标系 B
                // 参数2 源坐标系 A
                // 参数3 ros：：Time（0）取时间间隔最短的两个坐标关系帧计算相对关系
                // 返回值 geometry_msgs::TransformStamped 源相对于目标坐标系的相对关系
                geometry_msgs::TransformStamped Son1ToSon2=buffer.lookupTransform("turtle2","turtle1",ros::Time(0));
                // ROS_INFO("son1相对于son2的信息:父极:%s,子级：%s 偏移量：（%.2f,%.2f,%.2f)",
                //         Son1ToSon2.header.frame_id.c_str(),//turtle2
                //         Son1ToSon2.header.frame_id.c_str(),//turtle1
                //         Son1ToSon2.transform.translation.x,
                //         Son1ToSon2.transform.translation.y,
                //         Son1ToSon2.transform.translation.z 
                //         );

                //B根据相对坐标计算并组织速度消息
                geometry_msgs::Twist twist;
                //组织速度，只需要设置线速度的x与角速度的z
                //x=系数*开方(y^2+x^2)
                //z=系数*反正切（对边,邻边）
                twist.linear.x=0.5*sqrt(pow(Son1ToSon2.transform.translation.x,2)+pow(Son1ToSon2.transform.translation.y,2));
                twist.angular.z=4*atan2(Son1ToSon2.transform.translation.y,Son1ToSon2.transform.translation.x);
                //C发布
                pub.publish(twist);
                
            }
            catch(const std::exception& e)
            {
                ROS_INFO("错误提示：%s",e.what());
            }
            
        }
        // 5spinOnce（）
        return 0;
    }

## 小结
本案例集成度较高 建议旅顺思路后再照着文档流程独立实现

# TF坐标变换小结
坐标变换在机器人系统中是一个极其重要的组成模块，在 ROS 中 TF2 组件是专门用于实现坐标变换的，TF2 实现具体内容又主要介绍了如下几部分:

1.静态坐标变换广播器，可以编码方式或调用内置功能包来实现(建议后者)，适用于相对固定的坐标系关系

2.动态坐标变换广播器，以编码的方式广播坐标系之间的相对关系，适用于易变的坐标系关系

3.坐标变换监听器，用于监听广播器广播的坐标系消息，可以实现不同坐标系之间或同一点在不同坐标系之间的变换

4.机器人系统中的坐标系关系是较为复杂的，还可以通过 tf2_tools 工具包来生成 ros 中的坐标系关系图

5.当前 TF2 已经替换了 TF，官网建议直接学习 TF2，并且 TF 与 TF2 的使用流程与实现 API 比较类似，只要有任意一方的使用经验，另一方也可以做到触类旁通

# rosbag
在ros中关于数据的读取和留存以及读取实现，提供了专门的工具：rosbag

### 概念
用于录制和回放ROS主题的一个工具集
### 作用
实现数据的复用，方便调试/测试
### 本质
节点

录制时：订阅节点

重放时：发布节点，可读取磁盘文件，发布文件中的话题消息
## rosbag的使用（命令行）
### 实现过程
1. 准备

    -创建目录保存录制的文件

    -mkdir ./xxx
    -cd xxx

2. 开始录制

    -rosbag record -a -O 目标文件

    -操作小乌龟一段时间，结束录制使用 ctrl + c，在创建的目录中会生成bag文件。

3. 查看文件

    -rosbag info 文件名

4. 回放文件

rosbag play 文件名

重启乌龟节点，会发现，乌龟按照录制时的轨迹运动。

### 拓展
打开终端，输入

    rosbag
会显示rosbag的一些参数（功能）

    rosbag record --help
显示参数的子集
## rosbag编码使用
命令的使用不够灵活
可以编写程序实现你想要的操作

    #include"ros/ros.h"
    #include"rosbag/bag.h"
    // 需求：
    // 使用rosbag向磁盘文件写出数据（话题+消息）
    // 流程:
    // 1导包
    // 2初始化
    // 3创建rosbag对象
    // 4打开文件夹
    // 5写数据
    // 6关闭文件流
    int main(int argc,char *argv[]){
        // 2初始化
        setlocale(LC_ALL,"");
        ros::init(argc,argv,"bag_write");
        ros::NodeHandle nh;
        // 3创建rosbag对象
        rosbag::Bag bag;
        // 4打开文件夹
        bag.open("hello.bag",rosbag::BagMode::Write);
        // 5写数据
        std::msgs::String msg;
        msg.data="hello xxx";
        //参数1：话题 参数2：时间戳 参数3：消息
        bag.write("/chatter",ros::Time::now(),"");
        bag.write("/chatter",ros::Time::now(),"");
        bag.write("/chatter",ros::Time::now(),"");
        bag.write("/chatter",ros::Time::now(),"");

        // 6关闭文件流
        bag.close();
        return 0;
    }
## rqt工具箱
### 启动rqt工具箱
打开终端，键入 

    rqt  

或者键入

    rosrun rqt_gui rqt_gui

### rqt常用插件
1. rqt_graph  
    -圆形的是话题 方框是消息  
2. rqt_console

3. rqt_plot

4 rqt_bag

# 第五章小结
1. 坐标变换

    -了解坐标变换的消息格式  
    -静态坐标变换  
    -动态坐标变换（重点掌握  
    -多坐标变换（常用

2. rosbag（如何录制和重放消息

3. rqt工具箱

# 机器人系统仿真
## 仿真概述 
### 概念
通过计算机对实体机器人系统进行模拟的技术

#### 仿真实现的主要内容
1. 对机器人建模（URDF）
2. 创建仿真环境（Gazebo）
3. 感知环境（Rviz）

#### 仿真的优势
1. 低成本
2. 高效
3. 高安全性
#### 仿真的缺陷
1. 不能完全完美模拟真实的物理情况
2. 不支持模拟实际硬件缺陷或者一些临界状态
### 相关组件
1. URDF ：unified Robot Description Format(统一机器人描述格式)，可以以一种xml方式描述机器人的部分结构，比如底盘/摄像头/激光雷达/机械臂以及不同关节的自由度……，该文件可以被c++内置的解释器转换成**可视化的机器人模型**
2. rviz：Ros Visualization Tool(ros的三维可视化工具)，主要作用：**以维方式显示ROS消息** **将数据进行可视化表达**
3. Gazebo:3D动态模拟器
## URDF集成Rviz基本流程
URDF只是一个文件，需要在rviz或gazebo中渲染成图形化的机器人模型。
**跟随文档 步骤非常详细**
 

## URDF语法详解
差不多就是写标签 写属性 和前端的html很类似
### robot标签
类似于launch文件中的**launch**标签
### link标签
用于描述机器人部件的外观和物理属性  
属性也有如下属性  
visual:可视化  

collision:碰撞参数  
可以设置一些参数 当有障碍物进入该参数内则认为机器人发生了碰撞

intertrial:惯性矩阵  
可以设置重心以及其他不同的参数 模拟机器人的现实行为  
### joint标签
描述机器人的关节的运动学和动力学属性  
launch文件如果只加载父级参数 会报错  
解决方式是同时加载ros内置的joint_state_publisher和robot_state_publisher

#### launch文件代码如下
    <launch>
        <!-- 1.在参数服务器中载入urdf文件 -->
        <param name="robot_description" textfile="$(find urdf01_rviz)/urdf/urdf/demo03_joint.urdf"/>
        <!-- 2.启动rviz -->
        <node pkg="rviz" type="rviz" name="rviz" args="-d $(find urdf01_rviz)/config/show_mycar.rviz"/>
        <!-- 
            只有上述两条语句：
            表现：设置头显示位置与颜色异常
            提示：No transform from [camera] to [base_link]缺少camera到base_link的坐标变换
            原因：rviz中显示URDF时，必须发布不同部件之间的坐标系关系
            解决：ROS中提供了关于机器人模型显示的坐标系相关节点（两个）
        -->
        <!-- 关节状态发布节点 -->
        <node pkg="joint_state_publisher" type="joint_state_publisher" name="joint_state_publisher"/>
        <!-- 机器人状态发布节点 -->
        <node pkg="robot_state_publisher" type="robot_state_publisher" name="robot_state_publisher"/>

    </launch>

#### urdf
    <!-- 需求：设置机器人底盘，并添加摄像头 -->
    <robot name="mycar">
        <!-- 1底盘link -->
        <link name="base_link">
            <visual>
                <geometry>
                    <!-- 1.1立方体 -->
                    <box size="0.3 0.2 0.1"/>
                </geometry>
                <!-- 如果不设置origin标签则默认都是0 -->
                <origin xyz="0 0 0" rpy="0 0 0"/>
                <material name="car_color">
                    <color rgba="0.8 0.5 0 0.5"/>
                </material>
            </visual>
        </link>
        <!-- 2摄像头link -->
        <link name="camera">
            <visual>
                <geometry>
                    <!-- 1.1立方体 -->
                    <box size="0.02 0.05 0.05"/>
                </geometry>
                <!-- 先使用默认 -->
                <origin xyz="0 0 0.025" rpy="0 0 0"/>
                <material name="camera_color">
                    <color rgba="0 0 1 0.5"/>
                </material>
            </visual>
        </link>
        <!-- 3关节 -->
        <joint name="camera2base" type="continuous">
            <!-- 父级link -->
            <parent link="base_link"/>
            <!-- 子级link -->
            <child link="camera"/>
            <!-- 设置偏移量 -->
            <origin xyz="0.12 0 0.05" rpy="0 0 0"/>
            <!-- 设置关节旋转值参考的坐标轴 -->
            <axis xyz="0 0 1"/>
        </joint>
    </robot>



